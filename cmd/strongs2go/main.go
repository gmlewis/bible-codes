// -*- compile-command: "go run main.go ../../strongs/h*.html > hebrew.go"; -*-

// strongs2go parses HTML files from this website:
// https://www.kingjamesbibleonline.org/strongs-concordance/
// and converts the information to Go files for the "strongs" package.
//
// Usage:
//
//	go run main.go h*.html > hebrew.go
//	go run main.go g*.html > greek.go
package main

import (
	"bytes"
	"flag"
	"fmt"
	"log"
	"os"
	"strconv"
	"strings"
)

const (
	minLength = 5
)

func main() {
	flag.Parse()

	seen := map[string]bool{}
	for _, arg := range flag.Args() {
		log.Printf("Processing %q", arg)
		processFile(arg, seen)
	}
	fmt.Println("}")

	log.Printf("Done.")
}

func processFile(filename string, seen map[string]bool) {
	buf, err := os.ReadFile(filename)
	must(err)
	start := bytes.Index(buf, []byte("<table "))
	stop := bytes.Index(buf, []byte("</table>"))
	table := string(buf[start:stop])
	parts := strings.Split(table, "><a href=")[1:] // ignore first one.
	for _, part := range parts {
		processEntry(part, seen)
	}
}

func processEntry(htmlStr string, seen map[string]bool) {
	printHeader(htmlStr)
	tIndex := strings.Index(htmlStr, titlePrefix)
	if tIndex < 0 {
		log.Fatalf("could not find title in '%v'", htmlStr)
	}
	htmlStr = htmlStr[tIndex+len(titlePrefix):]
	qIndex := strings.Index(htmlStr, "' />")
	if qIndex < 0 {
		log.Fatalf("could not find ending single quote in '%v'", htmlStr)
	}
	// title := html.UnescapeString(htmlStr[:qIndex])  // preserve HTML escaping
	title := strings.TrimSpace(htmlStr[:qIndex])
	htmlStr = htmlStr[qIndex+4:]
	dIndex := strings.Index(htmlStr, ". ")
	if dIndex < 0 {
		log.Fatalf("could not find dot in '%v'", htmlStr)
	}
	strongNumStr := htmlStr[:dIndex]
	strongNum, err := strconv.Atoi(strongNumStr)
	must(err)
	htmlStr = htmlStr[dIndex+2:]
	endIndex := strings.Index(htmlStr, "</a>")
	if endIndex < 0 {
		log.Fatalf("could not find </a> in '%v'", htmlStr)
	}
	word := htmlStr[:endIndex]

	var wordRuneLen int
	var stripped []rune
	for _, r := range word {
		switch r {
		case 'ָ', 'ַ', 'ֵ', 'ֲ', 'ּ', 'ֹ', 'ֶ', 'ִ', '־', 'ׁ', 'ֱ', 'ְ', 'ֳ', 'ׂ', 'ֻ': // Hebrew diacritics
			continue
		}
		// log.Printf("r=%q", r)
		if r != ' ' {
			wordRuneLen++
		}
		stripped = append(stripped, r)
	}
	// log.Printf("%q length=%v", stripped, wordRuneLen)

	if wordRuneLen < minLength {
		fmt.Printf("\t// %q: // TOO SHORT // &Entry{Num: %v, Word: %q, Desc: %q},\n", string(stripped), strongNum, word, title)
		return
	}
	if seen[string(stripped)] {
		fmt.Printf("\t// %q: // DUP - SEE ABOVE // &Entry{Num: %v, Word: %q, Desc: %q},\n", string(stripped), strongNum, word, title)
		return
	}
	seen[string(stripped)] = true

	fmt.Printf("\t%q: &Entry{Num: %v, Word: %q, Desc: %q},\n", string(stripped), strongNum, word, title)
}

func printHeader(htmlStr string) {
	if hebrewPreamble != "" && strings.HasPrefix(htmlStr, hebrewPrefix) {
		fmt.Println(hebrewPreamble)
		hebrewPreamble = ""
	} else if greekPreamble != "" && strings.HasPrefix(htmlStr, greekPrefix) {
		fmt.Println(greekPreamble)
		greekPreamble = ""
	}
}

func must(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

const (
	greekPrefix  = "'../strongs-number-G"
	hebrewPrefix = "'../strongs-number-H"
	titlePrefix  = "' title='"
)

var (
	hebrewPreamble = `// Auto-generated by strongs2go - DO NOT EDIT!

package strongs

var Hebrew = map[string]*Entry{`

	greekPreamble = `// Auto-generated by strongs2go - DO NOT EDIT!

package strongs

var Greek = map[string]*Entry{`
)
